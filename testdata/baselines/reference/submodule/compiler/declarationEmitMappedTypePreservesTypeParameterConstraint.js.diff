--- old.declarationEmitMappedTypePreservesTypeParameterConstraint.js
+++ new.declarationEmitMappedTypePreservesTypeParameterConstraint.js
@@= skipped -61, +61 lines =@@

 //// [declarationEmitMappedTypePreservesTypeParameterConstraint.js]
 "use strict";
-// repro from https://github.com/microsoft/TypeScript/issues/54560
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.entriesOf = exports.buildSchema = void 0;
-const buildSchema = (version) => ({});
+const buildSchema = (version) => (({}));
 exports.buildSchema = buildSchema;
 const entriesOf = (o) => Object.entries(o);
 exports.entriesOf = entriesOf;
@@= skipped -31, +30 lines =@@
 export declare type ZodRawShape = {
     [k: string]: ZodTypeAny;
 };
-export declare const buildSchema: <V extends string>(version: V) => objectOutputType<{
+export declare const buildSchema: <V extends string>(version: V) => addQuestionMarks<baseObjectOutputType<{
     version: ZodLiteral<V>;
-}>;
+}>, undefined extends V ? never : "version"> extends infer T ? { [k in keyof T]: T[k]; } : never;
 type evaluate<t> = {
     [k in keyof t]: t[k];
 } & unknown;
@@= skipped -10, +10 lines =@@
     [k in keyof o]-?: [k, o[k] & ({} | null)];
 }[o extends readonly unknown[] ? keyof o & number : keyof o]>;
 export type entriesOf<o extends object> = evaluate<entryOf<o>[]>;
-export declare const entriesOf: <o extends object>(o: o) => entriesOf<o>;
+export declare const entriesOf: <o extends object>(o: o) => ({ [k in keyof o]-?: [k, o[k] & ({} | null)]; }[o extends readonly unknown[] ? keyof o & number : keyof o] extends infer T ? { [k in keyof T]: T[k]; } : never)[];
 export {};